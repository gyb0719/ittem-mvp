import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport '../../theme/colors.dart';\nimport '../../services/performance_service.dart';\nimport '../../services/image_cache_service.dart';\nimport 'skeleton/advanced_skeleton_widgets.dart';\n\n// 한국 모바일 UX 표준 구현\n// 당근마켓, 쿠팡, 네이버 등의 UX 패턴을 참고하여 구현\nclass KoreanMobileUX {\n  static const Duration fastLoadThreshold = Duration(seconds: 2);\n  static const Duration smoothScrollThreshold = Duration(milliseconds: 16);\n  static const double targetFPS = 60.0;\n  \n  // 성능 기준\n  static bool isLoadingFast(Duration loadTime) => loadTime <= fastLoadThreshold;\n  static bool isSmoothScroll(double fps) => fps >= 55;\n  static bool isResponsive(Duration responseTime) => responseTime <= Duration(milliseconds: 100);\n}\n\n// 빠른 로딩 위젯 (당근마켓 스타일)\nclass FastLoadingWidget extends StatefulWidget {\n  final Widget child;\n  final Widget? loadingWidget;\n  final Future<void> Function()? onLoad;\n  final Duration? timeout;\n  final VoidCallback? onTimeout;\n  final bool enableHapticFeedback;\n  \n  const FastLoadingWidget({\n    super.key,\n    required this.child,\n    this.loadingWidget,\n    this.onLoad,\n    this.timeout,\n    this.onTimeout,\n    this.enableHapticFeedback = true,\n  });\n  \n  @override\n  State<FastLoadingWidget> createState() => _FastLoadingWidgetState();\n}\n\nclass _FastLoadingWidgetState extends State<FastLoadingWidget> {\n  bool _isLoading = true;\n  bool _hasError = false;\n  String? _errorMessage;\n  late DateTime _startTime;\n  final PerformanceService _performanceService = PerformanceService();\n  \n  @override\n  void initState() {\n    super.initState();\n    _startTime = DateTime.now();\n    _loadContent();\n  }\n  \n  Future<void> _loadContent() async {\n    try {\n      _performanceService.startOperation('fast_loading');\n      \n      if (widget.onLoad != null) {\n        if (widget.timeout != null) {\n          await widget.onLoad!().timeout(widget.timeout!);\n        } else {\n          await widget.onLoad!();\n        }\n      }\n      \n      final loadTime = DateTime.now().difference(_startTime);\n      \n      _performanceService.endOperation('fast_loading', additionalData: {\n        'load_time_ms': loadTime.inMilliseconds,\n        'is_fast': KoreanMobileUX.isLoadingFast(loadTime),\n      });\n      \n      if (mounted) {\n        setState(() {\n          _isLoading = false;\n        });\n        \n        // 빠른 로딩 시 햅틱 피드백\n        if (widget.enableHapticFeedback && KoreanMobileUX.isLoadingFast(loadTime)) {\n          HapticFeedback.lightImpact();\n        }\n      }\n      \n    } catch (e) {\n      _performanceService.endOperation('fast_loading', additionalData: {\n        'error': e.toString(),\n      });\n      \n      if (mounted) {\n        setState(() {\n          _isLoading = false;\n          _hasError = true;\n          _errorMessage = e.toString();\n        });\n        \n        if (e.toString().contains('TimeoutException')) {\n          widget.onTimeout?.call();\n        }\n      }\n    }\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    if (_hasError) {\n      return _buildErrorWidget();\n    }\n    \n    if (_isLoading) {\n      return widget.loadingWidget ?? _buildDefaultLoadingWidget();\n    }\n    \n    return widget.child;\n  }\n  \n  Widget _buildDefaultLoadingWidget() {\n    return SmartSkeletonWidget(\n      isLoading: true,\n      child: Container(),\n      enableHapticFeedback: false,\n    );\n  }\n  \n  Widget _buildErrorWidget() {\n    return Container(\n      padding: const EdgeInsets.all(16),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Icon(\n            Icons.error_outline,\n            size: 48,\n            color: AppColors.error,\n          ),\n          const SizedBox(height: 16),\n          Text(\n            '로딩 중 오류가 발생했습니다',\n            style: const TextStyle(\n              fontSize: 16,\n              fontWeight: FontWeight.w600,\n              color: AppColors.textPrimary,\n            ),\n          ),\n          if (_errorMessage != null) ..[\n            const SizedBox(height: 8),\n            Text(\n              _errorMessage!,\n              style: const TextStyle(\n                fontSize: 14,\n                color: AppColors.textSecondary,\n              ),\n              textAlign: TextAlign.center,\n            ),\n          ],\n          const SizedBox(height: 16),\n          ElevatedButton(\n            onPressed: () {\n              setState(() {\n                _isLoading = true;\n                _hasError = false;\n                _errorMessage = null;\n                _startTime = DateTime.now();\n              });\n              _loadContent();\n            },\n            style: ElevatedButton.styleFrom(\n              backgroundColor: AppColors.primary,\n              foregroundColor: Colors.white,\n            ),\n            child: const Text('재시도'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// 부드러운 스크롤 위젯 (쿠팡 스타일)\nclass SmoothScrollWidget extends StatefulWidget {\n  final Widget child;\n  final ScrollController? controller;\n  final String scrollableId;\n  final bool enablePerformanceMonitoring;\n  \n  const SmoothScrollWidget({\n    super.key,\n    required this.child,\n    this.controller,\n    this.scrollableId = 'smooth_scroll',\n    this.enablePerformanceMonitoring = true,\n  });\n  \n  @override\n  State<SmoothScrollWidget> createState() => _SmoothScrollWidgetState();\n}\n\nclass _SmoothScrollWidgetState extends State<SmoothScrollWidget> {\n  late ScrollController _controller;\n  final PerformanceService _performanceService = PerformanceService();\n  bool _isScrolling = false;\n  DateTime? _scrollStartTime;\n  \n  @override\n  void initState() {\n    super.initState();\n    _controller = widget.controller ?? ScrollController();\n    \n    if (widget.enablePerformanceMonitoring) {\n      _controller.addListener(_onScroll);\n    }\n  }\n  \n  @override\n  void dispose() {\n    if (widget.controller == null) {\n      _controller.dispose();\n    }\n    super.dispose();\n  }\n  \n  void _onScroll() {\n    if (!_isScrolling) {\n      _isScrolling = true;\n      _scrollStartTime = DateTime.now();\n      _performanceService.startScrollTracking(widget.scrollableId);\n    }\n    \n    // 스크롤 끝 감지\n    Future.delayed(const Duration(milliseconds: 100), () {\n      if (_controller.position.activity?.isScrolling == false) {\n        _endScrollTracking();\n      }\n    });\n  }\n  \n  void _endScrollTracking() {\n    if (_isScrolling) {\n      _isScrolling = false;\n      \n      final scrollDuration = _scrollStartTime != null \n          ? DateTime.now().difference(_scrollStartTime!)\n          : Duration.zero;\n      \n      _performanceService.endScrollTracking(widget.scrollableId);\n      \n      // 부드러운 스크롤 평가\n      final currentFps = _performanceService.currentFps;\n      if (!KoreanMobileUX.isSmoothScroll(currentFps)) {\n        debugPrint('⚠️ Non-smooth scroll detected: ${currentFps.round()}fps');\n      }\n    }\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return widget.child;\n  }\n}\n\n// 반응형 터치 위젯 (네이버 스타일)\nclass ResponsiveTouchWidget extends StatefulWidget {\n  final Widget child;\n  final VoidCallback? onTap;\n  final Duration? responseTimeout;\n  final bool enableHapticFeedback;\n  final Color? pressedColor;\n  final double pressedOpacity;\n  \n  const ResponsiveTouchWidget({\n    super.key,\n    required this.child,\n    this.onTap,\n    this.responseTimeout,\n    this.enableHapticFeedback = true,\n    this.pressedColor,\n    this.pressedOpacity = 0.8,\n  });\n  \n  @override\n  State<ResponsiveTouchWidget> createState() => _ResponsiveTouchWidgetState();\n}\n\nclass _ResponsiveTouchWidgetState extends State<ResponsiveTouchWidget>\n    with SingleTickerProviderStateMixin {\n  late AnimationController _animationController;\n  late Animation<double> _scaleAnimation;\n  bool _isPressed = false;\n  DateTime? _pressStartTime;\n  final PerformanceService _performanceService = PerformanceService();\n  \n  @override\n  void initState() {\n    super.initState();\n    _animationController = AnimationController(\n      duration: const Duration(milliseconds: 100),\n      vsync: this,\n    );\n    _scaleAnimation = Tween<double>(\n      begin: 1.0,\n      end: 0.95,\n    ).animate(CurvedAnimation(\n      parent: _animationController,\n      curve: Curves.easeInOut,\n    ));\n  }\n  \n  @override\n  void dispose() {\n    _animationController.dispose();\n    super.dispose();\n  }\n  \n  void _onTapDown(TapDownDetails details) {\n    _pressStartTime = DateTime.now();\n    setState(() {\n      _isPressed = true;\n    });\n    _animationController.forward();\n    \n    if (widget.enableHapticFeedback) {\n      HapticFeedback.lightImpact();\n    }\n  }\n  \n  void _onTapUp(TapUpDetails details) {\n    _handleTapEnd();\n  }\n  \n  void _onTapCancel() {\n    _handleTapEnd();\n  }\n  \n  void _handleTapEnd() {\n    final responseTime = _pressStartTime != null \n        ? DateTime.now().difference(_pressStartTime!)\n        : Duration.zero;\n    \n    _performanceService.startOperation('touch_response');\n    _performanceService.endOperation('touch_response', additionalData: {\n      'response_time_ms': responseTime.inMilliseconds,\n      'is_responsive': KoreanMobileUX.isResponsive(responseTime),\n    });\n    \n    setState(() {\n      _isPressed = false;\n    });\n    _animationController.reverse();\n    \n    if (widget.onTap != null) {\n      final timeout = widget.responseTimeout ?? Duration(milliseconds: 100);\n      \n      Future.delayed(Duration.zero, () {\n        widget.onTap!();\n      }).timeout(timeout).catchError((e) {\n        debugPrint('Touch response timeout: $e');\n      });\n    }\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTapDown: _onTapDown,\n      onTapUp: _onTapUp,\n      onTapCancel: _onTapCancel,\n      child: AnimatedBuilder(\n        animation: _scaleAnimation,\n        builder: (context, child) {\n          return Transform.scale(\n            scale: _scaleAnimation.value,\n            child: AnimatedContainer(\n              duration: const Duration(milliseconds: 100),\n              decoration: BoxDecoration(\n                color: _isPressed \n                    ? (widget.pressedColor ?? Colors.grey.withOpacity(0.1))\n                    : Colors.transparent,\n                borderRadius: BorderRadius.circular(8),\n              ),\n              child: Opacity(\n                opacity: _isPressed ? widget.pressedOpacity : 1.0,\n                child: widget.child,\n              ),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n\n// 오프라인 대응 위젯\nclass OfflineAwareWidget extends StatefulWidget {\n  final Widget child;\n  final Widget? offlineWidget;\n  final Future<void> Function()? onRetryConnect;\n  \n  const OfflineAwareWidget({\n    super.key,\n    required this.child,\n    this.offlineWidget,\n    this.onRetryConnect,\n  });\n  \n  @override\n  State<OfflineAwareWidget> createState() => _OfflineAwareWidgetState();\n}\n\nclass _OfflineAwareWidgetState extends State<OfflineAwareWidget> {\n  bool _isOnline = true;\n  \n  @override\n  void initState() {\n    super.initState();\n    _checkConnectivity();\n  }\n  \n  Future<void> _checkConnectivity() async {\n    // 실제 구현에서는 connectivity_plus 패키지 사용\n    setState(() {\n      _isOnline = true; // 기본값\n    });\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    if (!_isOnline) {\n      return widget.offlineWidget ?? _buildDefaultOfflineWidget();\n    }\n    \n    return widget.child;\n  }\n  \n  Widget _buildDefaultOfflineWidget() {\n    return Container(\n      padding: const EdgeInsets.all(24),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Icon(\n            Icons.wifi_off,\n            size: 64,\n            color: AppColors.textTertiary,\n          ),\n          const SizedBox(height: 16),\n          Text(\n            '인터넷 연결을 확인해주세요',\n            style: const TextStyle(\n              fontSize: 18,\n              fontWeight: FontWeight.w600,\n              color: AppColors.textPrimary,\n            ),\n          ),\n          const SizedBox(height: 8),\n          Text(\n            '네트워크 연결을 확인하고 다시 시도해주세요',\n            style: const TextStyle(\n              color: AppColors.textSecondary,\n            ),\n            textAlign: TextAlign.center,\n          ),\n          const SizedBox(height: 24),\n          ElevatedButton(\n            onPressed: () async {\n              if (widget.onRetryConnect != null) {\n                await widget.onRetryConnect!();\n              }\n              _checkConnectivity();\n            },\n            child: const Text('다시 시도'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// 성능 표시 위젯 (개발 모드용)\nclass PerformanceIndicator extends StatefulWidget {\n  final Widget child;\n  final bool showFPS;\n  final bool showMemory;\n  final bool showNetwork;\n  \n  const PerformanceIndicator({\n    super.key,\n    required this.child,\n    this.showFPS = true,\n    this.showMemory = true,\n    this.showNetwork = false,\n  });\n  \n  @override\n  State<PerformanceIndicator> createState() => _PerformanceIndicatorState();\n}\n\nclass _PerformanceIndicatorState extends State<PerformanceIndicator> {\n  final PerformanceService _performanceService = PerformanceService();\n  \n  @override\n  Widget build(BuildContext context) {\n    // 릴리즈 모드에서는 표시하지 않음\n    if (const bool.fromEnvironment('dart.vm.product')) {\n      return widget.child;\n    }\n    \n    return Stack(\n      children: [\n        widget.child,\n        Positioned(\n          top: MediaQuery.of(context).padding.top + 10,\n          right: 10,\n          child: Container(\n            padding: const EdgeInsets.all(8),\n            decoration: BoxDecoration(\n              color: Colors.black.withOpacity(0.7),\n              borderRadius: BorderRadius.circular(8),\n            ),\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              mainAxisSize: MainAxisSize.min,\n              children: [\n                if (widget.showFPS)\n                  Text(\n                    'FPS: ${_performanceService.currentFps.round()}',\n                    style: TextStyle(\n                      color: _performanceService.currentFps >= 55 \n                          ? Colors.green \n                          : Colors.orange,\n                      fontSize: 12,\n                      fontWeight: FontWeight.bold,\n                    ),\n                  ),\n                if (widget.showMemory)\n                  Text(\n                    'Memory: ${_performanceService.currentMemoryUsageMB}MB',\n                    style: TextStyle(\n                      color: _performanceService.currentMemoryUsageMB < 200\n                          ? Colors.green\n                          : Colors.orange,\n                      fontSize: 12,\n                      fontWeight: FontWeight.bold,\n                    ),\n                  ),\n                if (widget.showNetwork)\n                  Text(\n                    'Network: OK',\n                    style: const TextStyle(\n                      color: Colors.green,\n                      fontSize: 12,\n                      fontWeight: FontWeight.bold,\n                    ),\n                  ),\n              ],\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\n// 한국 모바일 UX 유틸리티\nclass KoreanMobileUtils {\n  // 당근마켓 스타일 빠른 피드백\n  static void giveFastFeedback() {\n    HapticFeedback.lightImpact();\n  }\n  \n  // 쿠팡 스타일 로딩 완료 알림\n  static void notifyLoadComplete() {\n    HapticFeedback.mediumImpact();\n  }\n  \n  // 네이버 스타일 오류 알림\n  static void notifyError() {\n    HapticFeedback.heavyImpact();\n  }\n  \n  // 성능 체크\n  static bool isPerformanceGood() {\n    final service = PerformanceService();\n    return service.isPerformanceGood && service.isMemoryHealthy;\n  }\n  \n  // 최적 이미지 품질 결정\n  static ImageCacheQuality getOptimalImageQuality() {\n    if (isPerformanceGood()) {\n      return ImageCacheQuality.high;\n    } else {\n      return ImageCacheQuality.medium;\n    }\n  }\n}